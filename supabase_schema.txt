-- CodeTugaBuilds - Schema do Supabase
-- Este script configura o banco de dados completo, incluindo tabelas,
-- segurança em nível de linha (RLS), gatilhos (triggers) e inserção de dados iniciais.
-- Para usar: Copie e cole todo o conteúdo no Editor de SQL do seu projeto Supabase e execute.

-- Descomente a linha abaixo se precisar resetar as tabelas. CUIDADO: ISSO APAGARÁ TODOS OS DADOS.
-- DROP TABLE IF EXISTS public.build_components, public.builds, public.components, public.profiles CASCADE;


-- Tabela para armazenar os componentes de hardware disponíveis.
-- Os dados desta tabela são populados a partir de uma lista inicial (neste caso, inseridos diretamente).
CREATE TABLE IF NOT EXISTS public.components (
    id TEXT PRIMARY KEY NOT NULL,
    "Categoria" TEXT NOT NULL,
    "Produto" TEXT NOT NULL,
    "Preco" NUMERIC(10, 2) NOT NULL,
    "LinkCompra" TEXT
);
COMMENT ON TABLE public.components IS 'Tabela contendo todos os componentes de hardware disponíveis para montagem.';

-- Tabela de perfis de usuário, que estende a tabela `auth.users` do Supabase.
-- Esta tabela armazena dados públicos do perfil do usuário que não pertencem à autenticação.
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    nome TEXT NOT NULL,
    email TEXT NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.profiles IS 'Tabela de perfis que estende a tabela auth.users com metadados públicos.';


-- Tabela para armazenar as builds (montagens de PC) criadas pelos usuários.
CREATE TABLE IF NOT EXISTS public.builds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    nome TEXT NOT NULL,
    orcamento NUMERIC(10, 2) NOT NULL,
    data_criacao TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    requisitos JSONB, -- Armazena o objeto `PreferenciaUsuarioInput` como JSON.
    avisos_compatibilidade TEXT[] -- Armazena os avisos de compatibilidade da IA.
);
COMMENT ON TABLE public.builds IS 'Armazena as configurações de PC (builds) criadas pelos usuários.';


-- Tabela de junção para a relação muitos-para-muitos entre `builds` e `components`.
CREATE TABLE IF NOT EXISTS public.build_components (
    build_id UUID NOT NULL REFERENCES public.builds(id) ON DELETE CASCADE,
    component_id TEXT NOT NULL REFERENCES public.components(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (build_id, component_id) -- Chave primária composta.
);
COMMENT ON TABLE public.build_components IS 'Tabela de junção para associar componentes a uma build específica.';


-- Função de gatilho (trigger function) para criar um perfil de usuário automaticamente após o registro.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public -- `SECURITY DEFINER` permite que a função acesse `auth.users`.
AS $$
BEGIN
  -- Insere um novo perfil na tabela `public.profiles` com os dados do novo usuário de `auth.users`.
  -- `new.raw_user_meta_data->>'nome'` extrai o campo 'nome' passado nas opções do `signUp`.
  INSERT INTO public.profiles (id, nome, email)
  VALUES (new.id, new.raw_user_meta_data->>'nome', new.email);
  RETURN new;
END;
$$;

-- Gatilho (trigger) que executa a função `handle_new_user` após cada novo registro (`INSERT`) em `auth.users`.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Função RPC para salvar/atualizar uma build e seus componentes de forma atômica.
CREATE OR REPLACE FUNCTION public.upsert_build_with_components(
    p_build_id uuid,
    p_nome text,
    p_orcamento numeric,
    p_data_criacao timestamptz,
    p_requisitos jsonb,
    p_avisos_compatibilidade text[],
    p_component_ids text[]
)
RETURNS void
LANGUAGE plpgsql
-- SECURITY INVOKER é o padrão, então as políticas RLS serão aplicadas com base no usuário que chama a função.
AS $$
DECLARE
    v_current_user_id uuid := auth.uid();
BEGIN
    -- Etapa 1: Faz o "upsert" da build.
    -- Insere uma nova build ou atualiza uma existente com base no ID.
    INSERT INTO public.builds (id, user_id, nome, orcamento, data_criacao, requisitos, avisos_compatibilidade)
    VALUES (p_build_id, v_current_user_id, p_nome, p_orcamento, p_data_criacao, p_requisitos, p_avisos_compatibilidade)
    ON CONFLICT (id) DO UPDATE SET
        nome = EXCLUDED.nome,
        orcamento = EXCLUDED.orcamento,
        requisitos = EXCLUDED.requisitos,
        avisos_compatibilidade = EXCLUDED.avisos_compatibilidade;

    -- Etapa 2: Remove os componentes antigos associados a esta build para evitar duplicatas.
    -- A RLS garante que o usuário só pode deletar de builds que ele possui.
    DELETE FROM public.build_components WHERE build_id = p_build_id;

    -- Etapa 3: Insere os novos componentes usando um bulk insert performático.
    -- A RLS garante que o usuário só pode inserir em builds que ele possui.
    IF p_component_ids IS NOT NULL AND array_length(p_component_ids, 1) > 0 THEN
        INSERT INTO public.build_components (build_id, component_id)
        SELECT p_build_id, unnest(p_component_ids);
    END IF;
END;
$$;

-- Função RPC para deletar uma build e seus componentes de forma segura,
-- contornando problemas de RLS com ON DELETE CASCADE.
CREATE OR REPLACE FUNCTION public.delete_build(p_build_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER -- Executa com os privilégios do criador da função (superuser).
AS $$
BEGIN
  -- IMPORTANTE: Dentro de uma função SECURITY DEFINER, devemos verificar manually a permissão.
  -- Esta verificação garante que um usuário só pode deletar as próprias builds.
  IF EXISTS (SELECT 1 FROM public.builds WHERE id = p_build_id AND user_id = auth.uid()) THEN
    -- Etapa 1: Excluir explicitamente da tabela de junção 'build_components'.
    -- Como a função é SECURITY DEFINER, ela tem permissão para fazer isso, contornando a RLS.
    DELETE FROM public.build_components WHERE build_id = p_build_id;

    -- Etapa 2: Excluir da tabela principal 'builds'.
    DELETE FROM public.builds WHERE id = p_build_id;
  ELSE
    -- Lança um erro se o usuário tentar deletar uma build que não lhe pertence.
    RAISE EXCEPTION 'Permissão negada para deletar a build %', p_build_id;
  END IF;
END;
$$;


-- ### CONFIGURAÇÃO DE SEGURANÇA EM NÍVEL DE LINHA (ROW-LEVEL SECURITY - RLS) ###

-- 1. Habilita o RLS para todas as tabelas. Por padrão, isso bloqueia todo o acesso.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.builds ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.build_components ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.components ENABLE ROW LEVEL SECURITY;

-- 2. Políticas de Segurança para a tabela 'profiles'
DROP POLICY IF EXISTS "Usuários podem ver o próprio perfil." ON public.profiles;
CREATE POLICY "Usuários podem ver o próprio perfil."
ON public.profiles FOR SELECT
USING (auth.uid() = id); -- Permite a seleção (SELECT) apenas se o ID do usuário autenticado (`auth.uid()`) for igual ao ID da linha.

DROP POLICY IF EXISTS "Usuários podem atualizar o próprio perfil." ON public.profiles;
CREATE POLICY "Usuários podem atualizar o próprio perfil."
ON public.profiles FOR UPDATE
USING (auth.uid() = id); -- Permite a atualização (UPDATE) da própria linha.

-- 3. Políticas de Segurança para a tabela 'builds'
DROP POLICY IF EXISTS "Usuários autenticados podem criar builds." ON public.builds;
CREATE POLICY "Usuários autenticados podem criar builds."
ON public.builds FOR INSERT
TO authenticated WITH CHECK (auth.uid() = user_id); -- Permite a inserção (INSERT) para qualquer usuário autenticado, mas verifica se o `user_id` da nova linha é o mesmo do usuário que a está inserindo.

DROP POLICY IF EXISTS "Usuários podem ver as próprias builds." ON public.builds;
CREATE POLICY "Usuários podem ver as próprias builds."
ON public.builds FOR SELECT
USING (auth.uid() = user_id); -- Permite a seleção das builds que pertencem ao usuário.

DROP POLICY IF EXISTS "Usuários podem atualizar as próprias builds." ON public.builds;
CREATE POLICY "Usuários podem atualizar as próprias builds."
ON public.builds FOR UPDATE
USING (auth.uid() = user_id); -- Permite a atualização das builds que pertencem ao usuário.

DROP POLICY IF EXISTS "Usuários podem deletar as próprias builds." ON public.builds;
CREATE POLICY "Usuários podem deletar as próprias builds."
ON public.builds FOR DELETE
USING (auth.uid() = user_id); -- Permite a exclusão das builds que pertencem ao usuário.

-- 4. Políticas de Segurança para a tabela 'build_components'
-- Esta política permite que um usuário realize qualquer operação (SELECT, INSERT, UPDATE, DELETE)
-- na tabela 'build_components' SE, E SOMENTE SE, ele for o dono da build associada.
-- A cláusula USING se aplica a SELECT, UPDATE, DELETE.
-- A cláusula WITH CHECK se aplica a INSERT, UPDATE.
DROP POLICY IF EXISTS "Usuários podem gerenciar componentes das próprias builds." ON public.build_components;
CREATE POLICY "Usuários podem gerenciar componentes das próprias builds."
ON public.build_components FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM public.builds
    WHERE builds.id = build_components.build_id AND builds.user_id = auth.uid()
  )
)
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.builds
    WHERE builds.id = build_components.build_id AND builds.user_id = auth.uid()
  )
);

-- Habilitar RLS e criar políticas para a tabela 'components'
DROP POLICY IF EXISTS "Componentes são públicos para leitura." ON public.components;
CREATE POLICY "Componentes são públicos para leitura."
ON public.components FOR SELECT
TO authenticated, anon -- Concede permissão de leitura explícita para usuários anônimos e autenticados.
USING (true); -- A condição `true` significa que a política sempre se aplica.

-- FIM DA CONFIGURAÇÃO DO SCHEMA.
-- Os dados da tabela `public.components` devem ser populados separadamente,
-- por exemplo, fazendo o upload de um arquivo CSV através do painel do Supabase.